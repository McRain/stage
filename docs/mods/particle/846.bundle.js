"use strict";(self.webpackChunk_reneos_slider_mods_particle=self.webpackChunk_reneos_slider_mods_particle||[]).push([[846],{350:(t,e,i)=>{var s=i(786),o=(i(15),i(875));function n(){return class extends o.Object3D{constructor(){super(),this.type="StarsField",this.loader=new o.TextureLoader,this.clock=new o.Clock,this._numStars=100,this.speed=.001,this.size=.25,this.radius=10,this.points=null,this.geometry=null,this.material=null,this.createStarfield()}get numStars(){return this._numStars}set numStars(t){t!==this._numStars&&(this._numStars=t,this.rebuildStarfield())}getTypes(){return[...super.getTypes(),this.type]}createStarfield(){this.points&&(this.remove(this.points),this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose());const t=this.generateStarPositions();this.geometry=new o.BufferGeometry,this.geometry.setAttribute("position",new o.Float32BufferAttribute(t.verts,3)),this.geometry.setAttribute("color",new o.Float32BufferAttribute(t.colors,3)),this.material=new o.PointsMaterial({sizeAttenuation:!0,size:this.size,alphaTest:.5,transparent:!0,vertexColors:!0,blending:o.AdditiveBlending,map:this.loader.load("https://s3.eu-west-1.amazonaws.com/3dbuilder.reneos.com/assets/circle.png")}),this.points=new o.Points(this.geometry,this.material),this.add(this.points)}generateStarPositions(){const t=[],e=[];for(let i=0;i<this._numStars;i+=1){const i=this.getRandomSpherePoint(),s=(new o.Color).setHSL(i.hue,.2,Math.random());t.push(i.pos.x,i.pos.y,i.pos.z),e.push(s.r,s.g,s.b)}return{verts:t,colors:e}}getRandomSpherePoint(){const t=Math.random()*this.radius+this.radius,e=Math.random(),i=Math.random(),s=2*Math.PI*e,n=Math.acos(2*i-1);let r=t*Math.sin(n)*Math.cos(s),a=t*Math.sin(n)*Math.sin(s),l=t*Math.cos(n);return{pos:new o.Vector3(r,a,l),hue:.6,minDist:t}}rebuildStarfield(){const t=this.generateStarPositions();this.geometry.setAttribute("position",new o.Float32BufferAttribute(t.verts,3)),this.geometry.setAttribute("color",new o.Float32BufferAttribute(t.colors,3)),this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0}dispose(){this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose()}}}function r(){const t=document.createElement("canvas");t.width=64,t.height=64;const e=t.getContext("2d"),i=e.createRadialGradient(32,32,0,32,32,32);return i.addColorStop(0,"rgba(255, 230, 0, 1)"),i.addColorStop(.5,"rgba(255, 0, 0, 0.84)"),i.addColorStop(1,"rgba(255, 238, 0, 0.12)"),e.fillStyle=i,e.fillRect(0,0,64,64),new o.CanvasTexture(t)}new o.Clock;const a=new o.Clock;function l(){return class extends o.Object3D{constructor(){var t;super(),this.particleCount=5e3,this.geometry=new o.BufferGeometry,this.initializeGeometry(),this.material=(t=r(),new o.ShaderMaterial({uniforms:{pointTexture:{value:t},time:{value:0}},vertexShader:"\n            attribute float size;\n            attribute float alpha;\n            attribute vec3 velocity;\n            \n            varying float vAlpha;\n            uniform float time;\n            \n            void main() {\n                vAlpha = alpha;\n                \n                // Анимация движения\n                vec3 newPosition = position;\n                newPosition.x += sin(time * 0.001 + position.y) * 0.1;\n                newPosition.y += time * 0.01 * velocity.y;\n                newPosition.z += cos(time * 0.001 + position.x) * 0.1;\n                \n                // Циклическое возрождение частиц\n                if (newPosition.y > 10.0) {\n                    newPosition.y = -5.0;\n                }\n                \n                vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);\n                gl_PointSize = size * (300.0 / -mvPosition.z);\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform sampler2D pointTexture;\n            varying float vAlpha;\n            \n            void main() {\n                vec4 texColor = texture2D(pointTexture, gl_PointCoord);\n                gl_FragColor = vec4(1.0, 1.0, 1.0, texColor.a * vAlpha);\n                \n                // Мягкие края\n                float distanceFromCenter = length(gl_PointCoord - vec2(0.5));\n                if (distanceFromCenter > 0.5) {\n                    discard;\n                }\n                gl_FragColor.a *= 1.0 - smoothstep(0.3, 0.5, distanceFromCenter);\n            }\n        ",transparent:!0,depthWrite:!1})),this.points=new o.Points(this.geometry,this.material),this.add(this.points),this.time=0,this.update(0)}initializeGeometry(){const t=new Float32Array(3*this.particleCount),e=new Float32Array(this.particleCount),i=new Float32Array(this.particleCount),s=new Float32Array(3*this.particleCount);for(let o=0;o<this.particleCount;o++){const n=3*o,r=5*Math.random()+2,a=Math.random()*Math.PI*2,l=Math.random()*Math.PI;t[n]=Math.sin(l)*Math.cos(a)*r,t[n+1]=Math.cos(l)*r,t[n+2]=Math.sin(l)*Math.sin(a)*r,e[o]=.8*Math.random()+.4,i[o]=.4*Math.random()+.3,s[n]=.02*(Math.random()-.5),s[n+1]=.01*Math.random()+.005,s[n+2]=.02*(Math.random()-.5)}this.geometry.setAttribute("position",new o.BufferAttribute(t,3)),this.geometry.setAttribute("size",new o.BufferAttribute(e,1)),this.geometry.setAttribute("alpha",new o.BufferAttribute(i,1)),this.geometry.setAttribute("velocity",new o.BufferAttribute(s,3))}update(){requestAnimationFrame(this.update.bind(this)),this.time+=a.getDelta(),this.material.uniforms.time.value=this.time;const t=this.geometry.attributes.position.array,e=this.geometry.attributes.velocity.array,i=this.geometry.attributes.alpha.array;for(let s=0;s<this.particleCount;s++){const o=3*s;t[o]+=.005*Math.sin(.001*this.time+t[o+1]),t[o+2]+=.005*Math.cos(.001*this.time+t[o]),Math.sqrt(t[o]*t[o]+t[o+1]*t[o+1]+t[o+2]*t[o+2])>8?i[s]-=.01:i[s]<1&&(i[s]+=.005),i[s]<=0&&(t[o]=4*(Math.random()-.5),t[o+1]=4*(Math.random()-.5),t[o+2]=4*(Math.random()-.5),e[o]=.02*(Math.random()-.5),e[o+1]=.01*Math.random()+.005,e[o+2]=.02*(Math.random()-.5),i[s]=1)}this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.alpha.needsUpdate=!0}setPosition(t,e,i){this.points.position.set(t,e,i)}setScale(t){this.points.scale.set(t,t,t)}setColor(t,e,i){const s=new Float32Array(3*this.particleCount);for(let o=0;o<this.particleCount;o++){const n=3*o;s[n]=t,s[n+1]=e,s[n+2]=i}this.geometry.setAttribute("color",new o.BufferAttribute(s,3))}dispose(){this.geometry.dispose(),this.material.dispose(),this.points.parent&&this.points.parent.remove(this.points)}}}const h=new o.Clock;function m(){return class extends o.Object3D{constructor(){super();const{count:t=5e3,color:e=16777215,direction:i=new o.Vector3(0,1,0),speed:s=.75,spawnRadius:n=.1,minSize:a=.1,maxSize:l=.25,minLifetime:h=1,maxLifetime:m=3}={};this.type="Cloud",this.frustumCulled=!1,this.count=t,this.color=e,this.direction=i.clone().normalize(),this.speed=s,this.spawnRadius=n,this.minSize=a,this.maxSize=l,this.minLifetime=h,this.maxLifetime=m,this.particles=new Array(this.count);const d=new Float32Array(3*this.count),u=new Float32Array(this.count),p=new Float32Array(this.count);this.geometry=new o.BufferGeometry,this.geometry.setAttribute("position",new o.BufferAttribute(d,3)),this.geometry.setAttribute("aSize",new o.BufferAttribute(u,1)),this.geometry.setAttribute("aOpacity",new o.BufferAttribute(p,1));const c=r();this.material=new o.ShaderMaterial({transparent:!0,depthWrite:!1,uniforms:{uTexture:{value:c},uColor:{value:new o.Vector3((e>>16&255)/255,(e>>8&255)/255,(255&e)/255)}},vertexShader:"\n                    attribute float aSize;\n                    attribute float aOpacity;\n                    varying float vOpacity;\n                    void main() {\n                        vOpacity = aOpacity;\n                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                        gl_PointSize = aSize * (300.0 / -mvPosition.z);\n                        gl_Position = projectionMatrix * mvPosition;\n                    }\n                ",fragmentShader:"\n                    uniform sampler2D uTexture;\n                    uniform vec3 uColor;\n                    varying float vOpacity;\n                    void main() {\n                        vec4 texColor = texture2D(uTexture, gl_PointCoord);\n                        gl_FragColor = vec4(uColor, vOpacity) * texColor;\n                        if (gl_FragColor.a < 0.01) discard;\n                    }\n                "}),this.points=new o.Points(this.geometry,this.material),this.points.frustumCulled=!1,this.add(this.points);const g=new o.Vector3;this.getWorldPosition(g);for(let t=0;t<this.count;t++)this.resetParticle(t,g,!0);this.update()}getTypes(){return[...super.getTypes(),this.type]}randomSpawn(t){const e=this.spawnRadius*Math.random(),i=Math.random()*Math.PI*2,s=Math.acos(2*Math.random()-1);return new o.Vector3(t.x+e*Math.sin(s)*Math.cos(i),t.y+e*Math.sin(s)*Math.sin(i),t.z+e*Math.cos(s))}resetParticle(t,e,i=!1){const s=this.minLifetime+Math.random()*(this.maxLifetime-this.minLifetime);this.particles[t]={pos:this.randomSpawn(e),age:i?Math.random()*s:0,lifetime:s,size:this.minSize+Math.random()*(this.maxSize-this.minSize)}}update(){requestAnimationFrame(this.update.bind(this));const t=h.getDelta(),e=new o.Vector3;this.getWorldPosition(e);const i=this.geometry.attributes.position.array,s=this.geometry.attributes.aSize.array,n=this.geometry.attributes.aOpacity.array;for(let o=0;o<this.count;o++){const r=this.particles[o];r.age+=t,r.age>=r.lifetime&&this.resetParticle(o,e,!1),r.pos.addScaledVector(this.direction,this.speed*t);const a=r.age/r.lifetime,l=a<.2?a/.2:a>.8?(1-a)/.2:1;i[3*o]=r.pos.x-e.x,i[3*o+1]=r.pos.y-e.y,i[3*o+2]=r.pos.z-e.z,s[o]=r.size,n[o]=l}this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.aSize.needsUpdate=!0,this.geometry.attributes.aOpacity.needsUpdate=!0}}}const d=new o.Clock;function u(){return class extends o.Object3D{constructor({count:t=1e3,minSize:e=.5,maxSize:i=2,speed:s=1}={}){super(),this.type="FireParticles",this.count=t,this.minSize=e,this.maxSize=i,this.speed=s,this.enabled=!1,console.log(window.isEditor),this._emmiterMaterial=new o.MeshBasicMaterial({wireframe:!0,transparent:!0,opacity:window.isEditor?1:0}),this._emmiter=new o.Mesh(new o.SphereGeometry(1,5,5),this._emmiterMaterial),this._emmiter.isElementHelper=!0,this._emmiter.visible=!!window.isEditor,this.add(this._emmiter)}getTypes(){return[...super.getTypes(),this.type]}stop(){this.enabled&&(this.enabled=!1,this.points.parent.remove(this.points),this.geometry.dispose(),this.geometry=null)}start(){if(this.geometry)return;this.geometry=new o.BufferGeometry;const t=new o.Color(16755200),e=new o.Color(16711680),i=new Float32Array(3*this.count),s=new Float32Array(this.count),n=new Float32Array(this.count);let r=null;r=this._emmiter.geometry.getAttribute("position").array;for(let t=0;t<this.count;t++){if(r){const e=Math.floor(Math.random()*(r.length/3));i[3*t]=r[3*e],i[3*t+1]=r[3*e+1],i[3*t+2]=r[3*e+2]}else i[3*t]=Math.random()-.5,i[3*t+1]=0,i[3*t+2]=Math.random()-.5;s[t]=Math.random(),n[t]=o.MathUtils.lerp(this.minSize,this.maxSize,Math.random())}this.geometry.setAttribute("position",new o.BufferAttribute(i,3)),this.geometry.setAttribute("aLifetime",new o.BufferAttribute(s,1)),this.geometry.setAttribute("aSize",new o.BufferAttribute(n,1)),this.material=new o.ShaderMaterial({transparent:!0,depthWrite:!1,blending:o.AdditiveBlending,uniforms:{uTime:{value:0},uColor1:{value:t},uColor2:{value:e}},vertexShader:"\n        attribute float aLifetime;\n        attribute float aSize;\n        uniform float uTime;\n        varying float vLifetime;\n        void main() {\n          float age = mod(uTime + aLifetime, 1.0);\n          vec3 pos = position;\n          pos.y += age * 3.0;\n          vLifetime = 1.0 - age;\n\n          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n          gl_PointSize = aSize * (300.0 / -mvPosition.z);\n        }\n      ",fragmentShader:"\n        uniform vec3 uColor1;\n        uniform vec3 uColor2;\n        varying float vLifetime;\n        void main() {\n          float d = length(gl_PointCoord - vec2(0.5));\n          if (d > 0.5) discard;\n          vec3 color = mix(uColor2, uColor1, vLifetime);\n          gl_FragColor = vec4(color, vLifetime);\n        }\n      "}),this.points=new o.Points(this.geometry,this.material),this.add(this.points),this.time=0,this.enabled=!0,this.update()}update(){if(!this.enabled)return;requestAnimationFrame(this.update.bind(this));const t=d.getDelta();this.time+=t*this.speed,this.material.uniforms.uTime.value=this.time}}}o.PlaneGeometry;const p=s.default||s;!async function t(){if(console.log("particle"),p.engine.ready){if(p.engine.Factory.RegisterElement("StarsField",n,{label:"Stars Field"}),p.engine.Factory.RegisterElement("PointsField",l,{label:"Points Field"}),p.engine.Factory.RegisterElement("Cloud",m,{label:"Cloud Field"}),p.engine.Factory.RegisterElement("FireParticles",u,{label:"Fire Field"}),!window.isEditor)return;p.inspector.addToModels(["StarsField"],[{label:"Speed",head:{component:"Float",prop:"speed",props:{step:.1,min:.1,max:10,decimals:2},state:!0}},{label:"Stars",head:{component:"Float",prop:"numStars",props:{step:100,min:100,max:1e5,decimals:0},state:!0}},{label:"Size",head:{component:"Float",prop:"size",props:{step:.1,min:.1,max:10,decimals:2},state:!0,onupdate(t){t.rebuildStarfield()}}},{label:"Radius",head:{component:"Float",prop:"radius",props:{step:1,min:1,max:100,decimals:0},state:!0,onupdate(t){t.rebuildStarfield()}}}]),p.inspector.addToModels(["Cloud"],[{label:"maxDistance",head:{component:"Float",prop:"maxDistance",props:{step:.1,min:.1,max:100,decimals:1},state:!0}}]),p.inspector.addToModels(["FireParticles"],[{nonstate:!0,label:"Manage",head:{component:"Buttons",props:{buttons:[{label:"Start",handler:t=>{t.start()}},{label:"Stop",handler:t=>{t.stop()}}]},state:!0}}])}else p.engine.onload(t)}()}}]);