"use strict";(self.webpackChunk_reneos_slider_mods_particle=self.webpackChunk_reneos_slider_mods_particle||[]).push([[846],{350:(t,e,i)=>{var s=i(786),o=(i(15),i(875));new o.Clock;class r extends o.Object3D{constructor(){super(),this.type="StarsField",this.loader=new o.TextureLoader,this.clock=new o.Clock,this._numStars=100,this.speed=.001,this.size=.25,this.radius=10,this.points=null,this.geometry=null,this.material=null,this.createStarfield()}get types(){return["Object3D",this.type]}get numStars(){return this._numStars}set numStars(t){t!==this._numStars&&(this._numStars=t,this.rebuildStarfield())}getTypes(){return[...super.getTypes(),this.type]}createStarfield(){this.points&&(this.remove(this.points),this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose());const t=this.generateStarPositions();this.geometry=new o.BufferGeometry,this.geometry.setAttribute("position",new o.Float32BufferAttribute(t.verts,3)),this.geometry.setAttribute("color",new o.Float32BufferAttribute(t.colors,3)),this.material=new o.PointsMaterial({sizeAttenuation:!0,size:this.size,alphaTest:.5,transparent:!0,vertexColors:!0,blending:o.AdditiveBlending,map:this.loader.load("https://s3.eu-west-1.amazonaws.com/3dbuilder.reneos.com/assets/circle.png")}),this.points=new o.Points(this.geometry,this.material),this.add(this.points)}generateStarPositions(){const t=[],e=[];for(let i=0;i<this._numStars;i+=1){const i=this.getRandomSpherePoint(),s=(new o.Color).setHSL(i.hue,.2,Math.random());t.push(i.pos.x,i.pos.y,i.pos.z),e.push(s.r,s.g,s.b)}return{verts:t,colors:e}}getRandomSpherePoint(){const t=Math.random()*this.radius+this.radius,e=Math.random(),i=Math.random(),s=2*Math.PI*e,r=Math.acos(2*i-1);let a=t*Math.sin(r)*Math.cos(s),n=t*Math.sin(r)*Math.sin(s),l=t*Math.cos(r);return{pos:new o.Vector3(a,n,l),hue:.6,minDist:t}}rebuildStarfield(){const t=this.generateStarPositions();this.geometry.setAttribute("position",new o.Float32BufferAttribute(t.verts,3)),this.geometry.setAttribute("color",new o.Float32BufferAttribute(t.colors,3)),this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0}dispose(){this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose()}}function a(){const t=document.createElement("canvas");t.width=64,t.height=64;const e=t.getContext("2d"),i=e.createRadialGradient(32,32,0,32,32,32);return i.addColorStop(0,"rgba(255, 230, 0, 1)"),i.addColorStop(.5,"rgba(255, 0, 0, 0.84)"),i.addColorStop(1,"rgba(255, 238, 0, 0.12)"),e.fillStyle=i,e.fillRect(0,0,64,64),new o.CanvasTexture(t)}const n=new o.Clock;class l extends o.Object3D{constructor(){var t;super(),this.type="Cloud",this.particleCount=5e3,this.geometry=new o.BufferGeometry,this.initializeGeometry(),this.material=(t=a(),new o.ShaderMaterial({uniforms:{pointTexture:{value:t},time:{value:0}},vertexShader:"\n            attribute float size;\n            attribute float alpha;\n            attribute vec3 velocity;\n            \n            varying float vAlpha;\n            uniform float time;\n            \n            void main() {\n                vAlpha = alpha;\n                \n                // Анимация движения\n                vec3 newPosition = position;\n                newPosition.x += sin(time * 0.001 + position.y) * 0.1;\n                newPosition.y += time * 0.01 * velocity.y;\n                newPosition.z += cos(time * 0.001 + position.x) * 0.1;\n                \n                // Циклическое возрождение частиц\n                if (newPosition.y > 10.0) {\n                    newPosition.y = -5.0;\n                }\n                \n                vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);\n                gl_PointSize = size * (300.0 / -mvPosition.z);\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform sampler2D pointTexture;\n            varying float vAlpha;\n            \n            void main() {\n                vec4 texColor = texture2D(pointTexture, gl_PointCoord);\n                gl_FragColor = vec4(1.0, 1.0, 1.0, texColor.a * vAlpha);\n                \n                // Мягкие края\n                float distanceFromCenter = length(gl_PointCoord - vec2(0.5));\n                if (distanceFromCenter > 0.5) {\n                    discard;\n                }\n                gl_FragColor.a *= 1.0 - smoothstep(0.3, 0.5, distanceFromCenter);\n            }\n        ",transparent:!0,depthWrite:!1})),this.points=new o.Points(this.geometry,this.material),this.add(this.points),this.time=0,this.update(0)}get types(){return["Object3D",this.type]}initializeGeometry(){const t=new Float32Array(3*this.particleCount),e=new Float32Array(this.particleCount),i=new Float32Array(this.particleCount),s=new Float32Array(3*this.particleCount);for(let o=0;o<this.particleCount;o++){const r=3*o,a=5*Math.random()+2,n=Math.random()*Math.PI*2,l=Math.random()*Math.PI;t[r]=Math.sin(l)*Math.cos(n)*a,t[r+1]=Math.cos(l)*a,t[r+2]=Math.sin(l)*Math.sin(n)*a,e[o]=.8*Math.random()+.4,i[o]=.4*Math.random()+.3,s[r]=.02*(Math.random()-.5),s[r+1]=.01*Math.random()+.005,s[r+2]=.02*(Math.random()-.5)}this.geometry.setAttribute("position",new o.BufferAttribute(t,3)),this.geometry.setAttribute("size",new o.BufferAttribute(e,1)),this.geometry.setAttribute("alpha",new o.BufferAttribute(i,1)),this.geometry.setAttribute("velocity",new o.BufferAttribute(s,3))}update(){requestAnimationFrame(this.update.bind(this)),this.time+=n.getDelta(),this.material.uniforms.time.value=this.time;const t=this.geometry.attributes.position.array,e=this.geometry.attributes.velocity.array,i=this.geometry.attributes.alpha.array;for(let s=0;s<this.particleCount;s++){const o=3*s;t[o]+=.005*Math.sin(.001*this.time+t[o+1]),t[o+2]+=.005*Math.cos(.001*this.time+t[o]),Math.sqrt(t[o]*t[o]+t[o+1]*t[o+1]+t[o+2]*t[o+2])>8?i[s]-=.01:i[s]<1&&(i[s]+=.005),i[s]<=0&&(t[o]=4*(Math.random()-.5),t[o+1]=4*(Math.random()-.5),t[o+2]=4*(Math.random()-.5),e[o]=.02*(Math.random()-.5),e[o+1]=.01*Math.random()+.005,e[o+2]=.02*(Math.random()-.5),i[s]=1)}this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.alpha.needsUpdate=!0}setPosition(t,e,i){this.points.position.set(t,e,i)}setScale(t){this.points.scale.set(t,t,t)}setColor(t,e,i){const s=new Float32Array(3*this.particleCount);for(let o=0;o<this.particleCount;o++){const r=3*o;s[r]=t,s[r+1]=e,s[r+2]=i}this.geometry.setAttribute("color",new o.BufferAttribute(s,3))}dispose(){this.geometry.dispose(),this.material.dispose(),this.points.parent&&this.points.parent.remove(this.points)}}const h=new o.Clock;class m extends o.Object3D{constructor(){super();const{count:t=5e3,color:e=16777215,direction:i=new o.Vector3(0,1,0),speed:s=.75,spawnRadius:r=.1,minSize:n=.1,maxSize:l=.25,minLifetime:h=1,maxLifetime:m=3}={};this.type="Cloud",this.frustumCulled=!1,this.count=t,this.color=e,this.direction=i.clone().normalize(),this.speed=s,this.spawnRadius=r,this.minSize=n,this.maxSize=l,this.minLifetime=h,this.maxLifetime=m,this.particles=new Array(this.count);const d=new Float32Array(3*this.count),u=new Float32Array(this.count),p=new Float32Array(this.count);this.geometry=new o.BufferGeometry,this.geometry.setAttribute("position",new o.BufferAttribute(d,3)),this.geometry.setAttribute("aSize",new o.BufferAttribute(u,1)),this.geometry.setAttribute("aOpacity",new o.BufferAttribute(p,1));const c=a();this.material=new o.ShaderMaterial({transparent:!0,depthWrite:!1,uniforms:{uTexture:{value:c},uColor:{value:new o.Vector3((e>>16&255)/255,(e>>8&255)/255,(255&e)/255)}},vertexShader:"\n                    attribute float aSize;\n                    attribute float aOpacity;\n                    varying float vOpacity;\n                    void main() {\n                        vOpacity = aOpacity;\n                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                        gl_PointSize = aSize * (300.0 / -mvPosition.z);\n                        gl_Position = projectionMatrix * mvPosition;\n                    }\n                ",fragmentShader:"\n                    uniform sampler2D uTexture;\n                    uniform vec3 uColor;\n                    varying float vOpacity;\n                    void main() {\n                        vec4 texColor = texture2D(uTexture, gl_PointCoord);\n                        gl_FragColor = vec4(uColor, vOpacity) * texColor;\n                        if (gl_FragColor.a < 0.01) discard;\n                    }\n                "}),this.points=new o.Points(this.geometry,this.material),this.points.frustumCulled=!1,this.add(this.points);const y=new o.Vector3;this.getWorldPosition(y);for(let t=0;t<this.count;t++)this.resetParticle(t,y,!0);this.update()}get types(){return["Object3D",this.type]}randomSpawn(t){const e=this.spawnRadius*Math.random(),i=Math.random()*Math.PI*2,s=Math.acos(2*Math.random()-1);return new o.Vector3(t.x+e*Math.sin(s)*Math.cos(i),t.y+e*Math.sin(s)*Math.sin(i),t.z+e*Math.cos(s))}resetParticle(t,e,i=!1){const s=this.minLifetime+Math.random()*(this.maxLifetime-this.minLifetime);this.particles[t]={pos:this.randomSpawn(e),age:i?Math.random()*s:0,lifetime:s,size:this.minSize+Math.random()*(this.maxSize-this.minSize)}}update(){requestAnimationFrame(this.update.bind(this));const t=h.getDelta(),e=new o.Vector3;this.getWorldPosition(e);const i=this.geometry.attributes.position.array,s=this.geometry.attributes.aSize.array,r=this.geometry.attributes.aOpacity.array;for(let o=0;o<this.count;o++){const a=this.particles[o];a.age+=t,a.age>=a.lifetime&&this.resetParticle(o,e,!1),a.pos.addScaledVector(this.direction,this.speed*t);const n=a.age/a.lifetime,l=n<.2?n/.2:n>.8?(1-n)/.2:1;i[3*o]=a.pos.x-e.x,i[3*o+1]=a.pos.y-e.y,i[3*o+2]=a.pos.z-e.z,s[o]=a.size,r[o]=l}this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.aSize.needsUpdate=!0,this.geometry.attributes.aOpacity.needsUpdate=!0}}const d=new o.Clock;o.PlaneGeometry;class u extends o.Object3D{constructor({count:t=1e3,minSize:e=.5,maxSize:i=2,speed:s=1}={}){super(),this.type="FireParticles",this.count=t,this.minSize=e,this.maxSize=i,this.speed=s,this.enabled=!1,this._emmiterMaterial=new o.MeshBasicMaterial({wireframe:!0,transparent:!0,opacity:window.isEditor?1:0}),this._emmiter=new o.Mesh(new o.SphereGeometry(1,5,5),this._emmiterMaterial),this._emmiter.isElementHelper=!0,this._emmiter.visible=!!window.isEditor,this.add(this._emmiter)}get types(){return["Object3D",this.type]}getTypes(){return[...super.getTypes(),this.type]}stop(){this.enabled&&(this.enabled=!1,this.points.parent.remove(this.points),this.geometry.dispose(),this.geometry=null)}start(){if(this.geometry)return;this.geometry=new o.BufferGeometry;const t=new o.Color(16755200),e=new o.Color(16711680),i=new Float32Array(3*this.count),s=new Float32Array(this.count),r=new Float32Array(this.count);let a=null;a=this._emmiter.geometry.getAttribute("position").array;for(let t=0;t<this.count;t++){if(a){const e=Math.floor(Math.random()*(a.length/3));i[3*t]=a[3*e],i[3*t+1]=a[3*e+1],i[3*t+2]=a[3*e+2]}else i[3*t]=Math.random()-.5,i[3*t+1]=0,i[3*t+2]=Math.random()-.5;s[t]=Math.random(),r[t]=o.MathUtils.lerp(this.minSize,this.maxSize,Math.random())}this.geometry.setAttribute("position",new o.BufferAttribute(i,3)),this.geometry.setAttribute("aLifetime",new o.BufferAttribute(s,1)),this.geometry.setAttribute("aSize",new o.BufferAttribute(r,1)),this.material=new o.ShaderMaterial({transparent:!0,depthWrite:!1,blending:o.AdditiveBlending,uniforms:{uTime:{value:0},uColor1:{value:t},uColor2:{value:e}},vertexShader:"\n        attribute float aLifetime;\n        attribute float aSize;\n        uniform float uTime;\n        varying float vLifetime;\n        void main() {\n          float age = mod(uTime + aLifetime, 1.0);\n          vec3 pos = position;\n          pos.y += age * 3.0;\n          vLifetime = 1.0 - age;\n\n          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n          gl_PointSize = aSize * (300.0 / -mvPosition.z);\n        }\n      ",fragmentShader:"\n        uniform vec3 uColor1;\n        uniform vec3 uColor2;\n        varying float vLifetime;\n        void main() {\n          float d = length(gl_PointCoord - vec2(0.5));\n          if (d > 0.5) discard;\n          vec3 color = mix(uColor2, uColor1, vLifetime);\n          gl_FragColor = vec4(color, vLifetime);\n        }\n      "}),this.points=new o.Points(this.geometry,this.material),this.add(this.points),this.time=0,this.enabled=!0,this.update()}update(){if(!this.enabled)return;requestAnimationFrame(this.update.bind(this));const t=d.getDelta();this.time+=t*this.speed,this.material.uniforms.uTime.value=this.time}}const p=s.default||s;!async function t(){if(console.log("particle"),p.engine.ready){if(window.Factory.RegisterType({type:"StarsField",module:r,label:"Stars Field"}),window.Factory.RegisterType({type:"PointsField",module:l,label:"Points Field"}),window.Factory.RegisterType({type:"Cloud",module:m,label:"Cloud"}),window.Factory.RegisterType({type:"FireParticles",module:u,label:"Fire Particles"}),!window.isEditor)return;p.inspector.addToModels(["StarsField"],[{label:"Speed",head:{component:"Float",prop:"speed",props:{step:.1,min:.1,max:10,decimals:2},state:!0}},{label:"Stars",head:{component:"Float",prop:"numStars",props:{step:100,min:100,max:1e5,decimals:0},state:!0}},{label:"Size",head:{component:"Float",prop:"size",props:{step:.1,min:.1,max:10,decimals:2},state:!0,onupdate(t){t.rebuildStarfield()}}},{label:"Radius",head:{component:"Float",prop:"radius",props:{step:1,min:1,max:100,decimals:0},state:!0,onupdate(t){t.rebuildStarfield()}}}]),p.inspector.addToModels(["Cloud"],[{label:"maxDistance",head:{component:"Float",prop:"maxDistance",props:{step:.1,min:.1,max:100,decimals:1},state:!0}}]),p.inspector.addToModels(["FireParticles"],[{nonstate:!0,label:"Manage",head:{component:"Buttons",props:{buttons:[{label:"Start",handler:t=>{t.start()}},{label:"Stop",handler:t=>{t.stop()}}]},state:!0}}])}else p.engine.onload(t)}()}}]);